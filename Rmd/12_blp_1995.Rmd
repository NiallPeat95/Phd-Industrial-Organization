---
title: "Coding: BLP (1995)"
author: "Matteo Courthoud"
type: book
weight: 12
date: 2021-10-29
bibliography: references.bib
output: 
  html_notebook: 
    toc: true
    toc_depth: 2
  ioslides_presentation:
    widescreen: true
    smaller: true
    transition: 0
    slide_level: 3
  md_document:
    variant: markdown_mmd
    preserve_yaml: true
---

```{r load julia if not already loaded, include=FALSE, echo=FALSE}
if (!("JuliaCall" %in% (.packages()))) {
  library(JuliaCall)
  julia <- julia_setup("/Users/mcourt/Documents/Julia-1.5.app/Contents/Resources/julia/bin")
}
```

```{julia, include=FALSE, echo=FALSE}
#import Pkg
#Pkg.add("Optim")
#Pkg.add("Statistics")
#Pkg.add("Distributions")

using Optim
using Distributions
using Statistics
```

### Setting

From @berry1995automobile

-   


### Code Demand

```{julia}
function demand(p::Vector, mu::Real)::Vector
    """Compute demand"""
    u = [- p; 0] ./ mu            # Utility
    u = u .- max(u...)            # Normalize for simplicity
    e = exp.(u)                   # Take exponential
    d = e ./ sum(e)               # Compute demand
    return d[1:end-1]
end;
```

We can try with an example.

```{julia}
p = [1.5, 2, 3];
mu = 1.0;
demand(p, mu)
```

### Code Supply

```{julia}
function profits(p::Vector, mu::Real, c::Vector)::Vector
    """Compute profits"""
    d = demand(p, mu)           # Compute demand
    pr = (p - c) .* d           # Compute profits
    return pr
end;
```

We can try with an example.

```{julia}
c = [1, 1, 1.5];
profits(p, mu, c)
```



### Code Best Reply

We first code the best reply of firm $j$

```{julia}
function profits_j(pj::Real, j::Int, p::Vector, mu::Real, c::Vector)::Real
    """Compute profits of firm j"""
    p[j] = pj                 # Insert price of firm j
    pr = profits(p, mu, c)    # Compute profits
    return pr[j]
end;
```

Let's test it.

```{julia}
j = 1;
obj_fun(pj) = - profits_j(pj[1], j, copy(p), mu, c);
pj = optimize(x -> obj_fun(x), [1.0], LBFGS()).minimizer[1]
```

What are the implied profits now?

```{julia}
print("Profits old: ",  round.(profits(p, mu, c), digits=4))
p_new = [pj, p[2], p[3]];
print("Profits new: ",  round.(profits(p_new, mu, c), digits=4))
```

Indeed firm 1 has increased its profits.

### Code Equilibrium

We can now compute equilibrium prices

```{julia}
function equilibrium(p::Vector, mu::Real, c::Vector)::Vector
    """Compute equilibrium prices and profits"""
    
    # Until convergence
    dist = 1;
    iter = 0;
    while (dist > 1e-8) && (iter<1000)
    
        # Compute best reply for each firm
        p_old = copy(p);
        for j=1:length(p)
            obj_fun(pj) = - profits_j(pj[1], j, p, mu, c);
            optimize(x -> obj_fun(x), [1.0], LBFGS()).minimizer[1];
        end
        
        # Update distance
        dist = max(abs.(p - p_old)...);
        iter += 1;
    end
    return p
end;
```

### Code Equilibrium

Let's test it
```{julia}
# Compute equilibrium prices
p_eq = equilibrium(p, mu, c);
print("Equilibrium prices: ",  round.(p_eq, digits=4))

# And profits
pi_eq = profits(p_eq, mu, c);
print("Equilibrium profits: ",  round.(pi_eq, digits=4))
```

As expected the prices of the first 2 firms are lower and their profits are higher.


## References

------------------------------------------------------------------------
