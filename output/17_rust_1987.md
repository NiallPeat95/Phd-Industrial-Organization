---
author: Matteo Courthoud
bibliography: references.bib
date: 2021-10-29
link-citations: true
output:
  html_document:
    toc: true
    toc_collapsed: true
    toc_depth: 3
    toc_float: true
  html_notebook:
    toc: true
    toc_depth: 2
  ioslides_presentation:
    css: custom.css
    slide_level: 3
    smaller: true
    transition: 0
    widescreen: true
  md_document:
    preserve_yaml: true
    variant: markdown_mmd
title: "Coding: Rust (1987)"
type: book
weight: 17
---

### Setting

From Rust ([1988](#ref-rust1988maximum))

-   An agent owns a fleet to buses

-   Buses get old over time

-   The older the bus is, the most costly it is to maintain

-   The agent can decide to replace the bus engine with a new one, at a
    cost

-   **Dynamic trade-off**

    -   What is the best moment to replace the engine?

    -   You don’t want to replace an engine too early

        -   doesn’t change much

    -   You don’t want to replace an engine too late

        -   avoid unnecessary maintenance costs

### State

-   **State**: mileage of the bus

    $$x_t \in \lbrace 1, ..., 10 \rbrace $$

-   **State transitions**: with probability $\lambda$ the mileage of the
    bus increases

    $$
      x_{t+1} = \begin{cases}
      \min \lbrace x_t + 1,10 \rbrace  & \text { with probability } \lambda \newline 
      x_t & \text { with probability } 1 - \lambda
      \end{cases}
    $$

    Note that $\lambda$ does not depend on the value of the state

### Actions

-   **Action**: replacement decision $$
      i_t \in \lbrace 0, 1 \rbrace
      $$

-   **Payoffs**

    -   Per-period maintenance cost

    -   Cost of replacement $$
         u\left(x_{t}, i_{t}, \epsilon_{1 t}, \epsilon_{2 t} ; \theta\right)= 
         \begin{cases}
         -\theta_{1} x_{t}-\theta_{2} x_{t}^{2}+\epsilon_{0 t}, & \text { if } i_{t}=0 \newline 
         -\theta_{3}+\epsilon_{1 t}, & \text { if } i_{t}=1
         \end{cases}
         $$

### Simulation

-   Start with an initial value function $V(x_t)=0$

-   Compute expected value w.r.t. $\lambda$

    $$
    W(x_t) = \begin{cases}
    -\theta_1 x_t - \theta_2 x_t^2 + \beta \Big[(1-\lambda) V(x_t) + \lambda V(\min \lbrace x_t+1,10 \rbrace ) \Big] , & \text { if } i_t=0 \newline
    -\theta_3 + \beta \Big[(1-\lambda) V(0) + \lambda V(1) \Big] , & \text { if } i_t=1
    \end{cases}
    $$

-   Compute the new value of V $$
    V'(x_t) = \log \Big( e^{W(x_t|i_t=0)} + e^{W(x_t|i_t=1)} \Big)
    $$

-   Repeat until convergence

### Code

First we set the parameter values.

``` julia
# Set parameters
θ = [0.13; -0.004; 3.1];
λ = 0.82;
β = 0.95;
```

Then we set the state space.

``` julia
# State space
x = Vector(0:10);
```

### Static utility

First, we can compute static utility.

``` julia
function compute_U(θ::Vector, x::Vector)::Matrix
    """Compute static utility"""
    u1 = - θ[1]*x - θ[2]*x.^2       # Utility of not investing
    u2 = - θ[3]*ones(size(x))       # Utility of investing
    U = [u1 u2]                     # Combine in a matrix
    return U
end;
```

### Value Function

We can now set up the value function iteration

``` julia
function compute_V(θ::Vector, λ::Number, β::Number, x::Vector)::Matrix
    """Compute value function by Bellman iteration"""
    K = length(x)                                 # Dimension of the state space
    U = compute_U(θ, x)                           # Static utility
    index_λ = Int[1:K [2:K; K]];                  # Mileage index
    index_I = Int[1:K ones(K,1)];                 # Investment index

    # Iterate the Bellman equation until convergence
    V_bar = zeros(K, 2);
    V_bar1 = V_bar;
    dist = 1;
    iter = 0;
    while dist>1e-8
        V = log.(sum(exp.(V_bar), dims=2))          # Compute value
        Exp_V = V[index_λ] * [1-λ; λ]               # Compute exponential value
        V_bar1 = β * (U + Exp_V[index_I])           # Compute v-specific
        dist = max(abs.(V_bar1 - V_bar)...);        # Check distance
        iter += 1;
        V_bar = V_bar1                              # Update value function
    end
    return V_bar
end;
```

### Solving the Model

We can now solve for the value function.

``` julia
# Compute value function
V_bar = compute_V(θ, λ, β, x);
```

### DGP

Now that we know how to compute the equilibrium, we can simulate the
data.

``` julia
function generate_data(θ::Vector, λ::Number, β::Number, x::Vector, N::Int)::Tuple
    """Generate data from primitives"""
    V_bar = compute_V(θ, λ, β, x)               # Solve model
    ε = rand(Gumbel(0,1), N, 2)                 # Draw shocks
    Xt = rand(x.+1, N)                          # Draw states
    Iv = (((V_bar[Xt,:] + ε) * [-1;1]) .> 0)    # Compute investment decisions
    δ = (rand(Uniform(0,1), N) .< λ)            # Compute mileage shock
    Xt1 = min.(Xt .* (Iv.==0) + δ, max(x...))   # Compute next state
    df = DataFrame(Xt=Xt, Iv=Iv, Xt1=Xt1)
    CSV.write("../data/rust.csv", df)
    return Xt, Iv, Xt1
end;
```

### The Data

How many investment decisions do we observe?

``` julia
# Generate data
N = Int(1e5);
x_t, Iv, x_t1 = generate_data(θ, λ, β, x, N);
print("we observe ", sum(Iv), " investment decisions in ", N, " observations")
```

    ## we observe 22044 investment decisions in 100000 observations

### Estimation - Lambda

-   First we can estimate the value of lambda as the mean

    $$
    \hat \lambda = \mathbb E_n \Big[ (x_{t+1}-x_t) \mid i_{t}=0 \wedge x_{t}<10 \Big]
    $$

``` julia
# Estimate lambda
Δ = x_t1 - x_t;
λ_ = mean(Δ[(Iv.==0) .& (x_t.<10)]);

print("Estimated lambda: $λ_ (true = $λ)")
```

    ## Estimated lambda: 0.8190565382233433 (true = 0.82)

### Estimation - theta

-   Take a parameter guess $\theta_0$

-   Compute the corresponding value function
    $V(x_t | \hat \lambda, \theta_0)$

-   Compute the implied choice probabilities

-   Compute the likelihood

    $$
    \mathcal{L}(\theta)=\prod_{t=1}^{T}\left(\hat{\operatorname{Pr}}\left(i=1 \mid x_{t}, \theta\right) \mathbb{1}\left(i_{t}=1\right)+\left(1-\hat{\operatorname{Pr}}\left(i=0 \mid x_{t}, \theta\right)\right) \mathbb{1}\left(i_{t}=0\right)\right)
    $$

-   Repeat the above to find a minimum of the likelihood function

### Code

``` julia
function logL(θ0::Vector)::Number
    """Compute log-likelihood function"""
    # Compute value
    V_bar = compute_V(θ0, λ_, β, x)

    # Implied choice probabilities
    pr_I = exp.(V_bar[:,2]) ./ (exp.(V_bar[:,1]) + exp.(V_bar[:,2]))

    # Likelihood
    logL = sum(log.(pr_I[x_t[Iv.==1]])) + sum(log.(1 .- pr_I[x_t[Iv.==0]]))
    return -logL
end;
```

We can check the likelihood at the true value:

``` julia
# True likelihood value
print("The likelihood at the true values is ", logL(θ))
```

    ## The likelihood at the true values is 49103.37253483445

### Estimating Theta

``` julia
# Select starting values
θ0 = Float64[0,0,0];

# Optimize
θ_ = optimize(logL, θ0).minimizer;
print("Estimated thetas: $θ_ (true = $θ)")
```

    ## Estimated thetas: [0.12484838091347551, -0.0035688281695299097, 3.0947498708824512] (true = [0.13, -0.004, 3.1])

### Starting Values

Starting values are important!

``` julia
# Alternative starting values
θ0 = Float64[1,1,1];

# Optimize
θ_ = optimize(logL, θ0).minimizer;
print("Estimated thetas: $θ_ (true = $θ)")
```

    ## Estimated thetas: [1.0, 1.0, 1.0] (true = [0.13, -0.004, 3.1])

## References

------------------------------------------------------------------------

<div id="refs" class="references csl-bib-body hanging-indent"
markdown="1">

<div id="ref-rust1988maximum" class="csl-entry" markdown="1">

Rust, John. 1988. “Maximum Likelihood Estimation of Discrete Control
Processes.” *SIAM Journal on Control and Optimization* 26 (5): 1006–24.

</div>

</div>
